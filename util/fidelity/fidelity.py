import torch


def fidelity_single_qubit_control(U_out: torch.Tensor, U_target: torch.Tensor, num_qubits: int=1) -> torch.Tensor:
    """Entanglement fidelity F = (|Tr(U_out^† U_target)|² + d) / d(d + 1)."""
    # trace over last two dims, keep batch
    # Batched conjugate transpose and matrix multiplication
    U_out_dagger = U_out.conj().transpose(-1, -2)  # [batch, 2, 2]
    product = U_out_dagger @ U_target  # [batch, 2, 2]

    # print(product, product.shape)

    # Batched trace calculation
    trace = torch.einsum('bii->b', product)  # [batch]
    trace_squared = torch.abs(trace) ** 2

    d = 2 ** num_qubits

    return (trace_squared + d) / (d * (d + 1))


def fidelity_entangled_control(U_out: torch.Tensor, U_target: torch.Tensor, num_qubits: int=1) -> torch.Tensor:
    """
    Returns fidelity such that U_out is effectively a product state U_target (x) SU(2)

    Parameters
    ----------
    U_out : torch.Tensor
        Shape (B, 4, 4) unitary generated by the model. This unitary acts on both system and ancilla qubit
    U_target : torch.Tensor
        Shape (B, 2, 2) unitary, which is the desired unitary gate on the system qubit
    Returns
    -------
    torch.Tensor
        Shape ``(B,)`` fidelity of each gate

    -----------
    Computation
    -----------
    We can define fidelity to be
    F := max_{W \\in SU(2)} 1/16 * |Tr[(U_target^\\dagger (x) W^\\dagger) * U_out]|^2

    Let U_eff = (U_target^\\dagger (x) I) * U_out] and X = Tr_1[U_eff]
    SVD of X is X = U diag(s1, s2) V^\\dagger

    Notice that the trace is maximized when W = U V^\\dagger. 

    Hence F = 1/16 * (s1 + s2)^2, and the average fidelity is

    F_avg = (4 * F + 1)/5
    """
    assert U_out.shape[1] == U_out.shape[2] == 4, f"U_out is not a 4x4 unitary. Shape: {U_out.shape}"
    assert U_target.shape[1] == U_target.shape[2] == 2, f"U_target is not a 2x2 unitary. Shape: {U_target.shape}"
    assert U_out.shape[0] == U_target.shape[0], f"U_out and U_target not matching in length: {U_out.shape[0]} != {U_target.shape[0]}"

    device = U_out.device
    dtype = U_out.dtype
    B = U_out.shape[0]
    I2 = torch.eye(2, dtype=dtype, device=device).expand(B, 2, 2)

    U_t_dag = U_target.conj().transpose(-2, -1)

    # Extract 2x2 blocks of U_out
    A = U_out[:, 0:2, 0:2]  # (B,2,2)
    B = U_out[:, 0:2, 2:4]
    C = U_out[:, 2:4, 0:2]
    D = U_out[:, 2:4, 2:4]

    # Entries of U_t_dag, shaped for broadcast with 2x2 blocks
    a = U_t_dag[:, 0, 0].unsqueeze(-1).unsqueeze(-1)  # (B,1,1)
    b = U_t_dag[:, 0, 1].unsqueeze(-1).unsqueeze(-1)
    c = U_t_dag[:, 1, 0].unsqueeze(-1).unsqueeze(-1)
    d = U_t_dag[:, 1, 1].unsqueeze(-1).unsqueeze(-1)

    # U_t_dag (x) I is [[aI, bI], [cI, dI]]

    # X = block00 + block11 of (U_t_dag ⊗ I) U_out, derived directly:
    # block00 = a*A + b*C, block11 = c*B + d*D
    X = a * A + b * C + c * B + d * D  # (B,2,2)

    # Singular values of each X
    S = torch.linalg.svdvals(X)  # (B, 2)

    # Nuclear norm = sum of singular values
    nuc_norm = S.sum(dim=-1)  # (B,)

    F = (nuc_norm ** 2) / 16

    return (2 * F.real + 1) / 3